## 概念

1. 架构是如何产生的？

- 初始 - 无架构的概念，前端代码内嵌到后端应用中
- 后端 mvc 架构 - 将视图层(通过一些逻辑从 modal 获取数据，也可能是 modal 通过一些逻辑想 view 注入数据)，数据层，应用层(所有的数据修改，修改显示) 做分离

  缺点: 重度依赖开发环境，代码混淆严重 (比如我们在做调试的时候，需要走整个流程，需要启动后端的所有代码，安装所有的依赖，然后从本地启动，调试，这个复杂度是很高的，而且我们的所有代码还是写在后端的应用中，没有拆解，而且有很多依赖是通过后端服务注入的，这个时候我们想去区别一些显示的代码，和逻辑控制的代码，是比较困难的，如果说所有的内容都集中在后端的环境里，势必会对整体的开发造成很大的影响)

2. 前后端分离架构

- 将前端代码从后端环境中提炼出来(ajax 促进了前后端分离架构的发展) - 多页面架构

  缺点：前端缺乏独立部署的能力，整体流程依赖后端环境

3. nodejs 的使用推动了前端技术的发展

- 打包工具，构建工具
- 多元化前端开发方式，使得前端开发可以脱离整体后端环境

4. 单页面架构 -打包 框架 ui 库

优势：1. 切换页面无刷新浏览器，用户体验好 2. 组件化的开发方式，极大提升了代码复用率

劣势：1. 不利于 SEO，首次渲染会出现比较长时间的白屏 2.

5. 大前端时代

- 后端框架
- 包管理工具
- node 版本管理

6. 总结

- 过于灵活的实现也导致前端应用拆分过多，维护困难
- 往往一个功能或需求会跨两三个项目进行开发

7. 微前端等新型架构，上述结论衍生出来的一些架构

- 优势 - 能提供的便利：
  1. 与技术栈无关
  2. 主框架不限制接入应用的技术栈，微应用具备完全自主权
  3. 独立开发，独立部署
  4. 增量升级 - 无论是上线，发布还是开发，过程都是可以使用增量升级的一个流程
  5. 微前端是一种非常好的实施 渐进式重构 的手段和策略。 渐进式重构, 也就是在一个大型的应用里，我们希望把一部分页面通过重构的方式重写，我们不想然他失去无刷新跳转的这样一个过程
  6. 微应用仓库独立，前后端可独立开发，主框架自动完成同步更新
  7. 独立运行时 - 每个子应用都是独立运行的
  8. 每个微应用之间状态隔离，运行时状态不共享
- 劣势

1. 接入难度较高
2. 应用场景 - 移动端少，管理端多

## 架构设计原则

软件设计原则与分层 - 不只是设计，平常开发也可能会使用到这些思想

### 单一职责原则

永远不应该有多于一个原因来改变某个类。
理解？对于一个类而言，应该仅有一个引起他变化的原因
应用：如果一个类拥有了两种职责，那么就可以将这个类分为两个类。比如登陆验证用户名和密码，很多情况会讲这些判断写再一起，开发负担，后期维护，最好拆分为两个方法去实现
开发封闭原则
软件实体拓展应该是开放的，但对于修改应该是封闭的
理解？对拓展开放，对修改封闭。可以去拓展类，不要去修改类
应用：当需求有改动，应该尽量用继承和组合的方式来拓展类的功能，而不是直接修改类的代码。比如再上面的验证过程中，再增加一个图片验证码的功能，通过之后再去验证密码，如果直接去修改验证密码的方法，不仅会浪费大量的开发时间，还有测试时间，纠错时间，上线后也不缺包是否会对验证密码这个功能有影响。
解决方法：封装一个图片验证码的函数，返回 true/false 来判断接下来的流程。不会影响验证密码的功能。
里氏替换原则
理解？父类一定能被子类替换
最少知识原则
只与你最直接的交流对象
可以归纳为一句话：高内聚，低耦合。将我们的代码和其他有关联的代码进行最少的关联
应用：做系统设计时，尽量减少依赖关系。比如上述验证过程，图片验证码是强相关的，我们只需要知道结果，就可以进行校验
接口隔离原则
接口？这个不是我们日常获取数据的接口，而是在程序设计的时候预设一部分类型，来限定一个类是怎样实现的
一个类和另一个类之间的依赖性，应该依赖于尽可能小的接口
理解？不要对外暴露没有实际意义的接口。用户不应该依赖他不需要的接口
应用：当需要对外暴露接口时，如果是封闭要对外提供，尽量删除
依赖倒置原则
高层模块不应该依赖低层模块，他们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
理解？面向接口编程，不应该面向类编程
并不是说，所有的类都要有一个接口，而是说，如果有接口，就尽量使用接口来编程
总结
SOLID 原则，只有满足了这六大原则，才能设计出稳定的架构。
补充设计原则
组合/聚合服用原则
当要拓展类的功能时，优化考虑组合，而不是继承
该原则经常在 23 中设计模式中出现
如，代理模式，适配器模式，装饰模式
无环依赖模式
当 A 模块依赖于 B 模块， B 模块依赖于 C 模块， C 模块依赖于 A 模块，此时将会出现循环依赖
在设计中应该避免这类问题，可通过引入 中介者模式 解决
共同封装原则
应该将一变的类放在同一哥包类(方法体内)，将变化隔离出来
该原则是 开放-封闭原则 的诞生
共同重用原则
如果重用了包中的一个类，那么也就相当于重用了包中的所有类我们要尽可能减小包的大小。
好莱坞原则
控制反转，依赖注入 - import/require，可以使用里面的一些方法和内容
不需要主动创建对象，而是由容器来帮我们创建和管理这些对象。
不要重复你自己
不要让重复的代码到处都是，要让他们足够的重用，所以要尽可能的封装
保持他的简单和傻瓜
保持系统界面简洁，功能实用，操作方便
高内聚，低耦合
模块内部要做到内度高，模块之间需要做到耦合度低
理解？如果说我们整体的模块或方法的内部用到了一些基础的功能，那我们一定要做到这次基础的功能是高度内聚的， 方法和方法间，他们的耦合度要降低 ，降低了耦合度，我们在重用和复用的时候整体的负担都会变得更小
关注点分离
将一个复杂的问题分离为多个简单的问题，然后逐个解决。也就是分而治之
难点？如何进行分离，分离的颗粒度是多
你不需要它
不要一开始就把系统设计的非常复杂，不要陷入 过度设计 的深渊
让系统足够简单，而又不失拓展性
软件分层设计

1. 系统级架构
   应用在整个系统内，如与后台服务如何通信，与第三方系统如何集成。
   设计前端首要条件：了解前端系统与其他系统之间的关系。
   关系包括：业务关系和协作机制
   设计后端：只需要规定与后台数据传输的机制 - 还需要了解整体与后端的数据通信
   包括：api 设计规则，访问授权的一个开放标准 OAuth 跳转 token 的验证，数据传递 cookie 等
   前端与后端关系考虑的主要因素：前后端分离的架构设计
   前后端分离架构 - 其实是如何实施技术决策，用户鉴权，Api 接口管理和设计，Api 文档的管理，Mock 的使用，BFF(服务于前端的后端 nodejs)，是否需要服务端渲染等。
2. 微前端
   在一个系统内，微前端是应用间的架构方案。- 也就是说整体的子应用是运行在一个系统之内的
   在多个应用之间，微前端则是一种系统间的架构方案。微前端负责的是调度所有的子应用，不管是每一个子应用的渲染，数据依赖的更新和获取，子应用的激活和卸载，等都是有微前端这个框架去完成的。
   总体而言，微前端是多个前端应用以某种形式结合在一起的应用。
   解决问题？
   旨在解决一个单体应用在一个相对长的时间跨度下，由于参与的人员，团队的增多，变迁，从一个普通应用演变成一个巨石应用后，随之而来的是很难维护的问题。

单实例：即同一个时刻，只有一个字应用被展示，子应用具备一个完整应用的生命周期。其他子应用都是处于不激活的状态。
多实例：通常基于 url 的变化来做子应用的切换。单实例和多实例通常都是基于 url 的变化。同一时刻可以展示多个子应用。
通常使用 web Components 来做子应用封装，子应用更像是一个业务组件而不是应用。
所以可以理解为 系统级架构或者应用级架构 3.应用级架构
应用级架构可以看作系统级架构的细化。
单个应用与其他外部应用的关系，微服务架构下多个应用的协作，数据交换等。包括但不局限于这几种形式
脚手架
模式库 - 方法/UI 库
设计系统 - 整体的应用级架构，他的整体内部实现的功能，与外部的信息交互等等这样的内容。 4.模块级架构
这部分内容是我们开始业务编码之前进行设计，我们称之为 迭代。 5.代码级架构
主要是 规范和原则
而对于整体代码级架构间的内容，我们可以理解为开发的流程，代码质量以及改善，规范的设计，而不是改善
这几个架构 是从上到下 逐级递减的。
注意点 在开发中，注意可维护性，可拓展性，简单的代码维护性高，越是写的抽象的代码越是难以维护。

# 微前端实现方式对比

## Iframe

通过 iframe 去引入一些其他的页面， 然后在某一个容器内进行显示，使用 postMessage 进行页面传参

1. 优势

- 技术成熟
- 支持页面嵌入 - 通过 url 可以将页面的内容引入到某一个容器进行显示
- 天然支持沙箱隔离，独立运行

2. 劣势

- 页面之前可以使不同的域名，如果需要鉴权，工作量会加大，还包括一些其他跨域问题的处理
- 需要对应的设计一整套应用通信机制，如何监听，传参格式等
- 应用加载、渲染、缓存体系的实现

## web component

支持我们自己定义一些自己的组件，和标签，也可以定义所有标签之中的默认行为，可以将我们一些功能定义成我们自己的组件

1. 优势

- 支持自定义元素
- 支持 shadow dom，并可通过关联进行控制
- 支持模板和插槽，引入自定义组件内容

2. 劣势

- 接入微前端需要重写当前项目
- 生态系统不完整，技术过新如意出现兼容性问题
- 整体架构设计复杂，组件与件之间拆分过细，容易造成通讯和控制繁琐

```js
// shadow dom 学习
```

## 自研框架

1. 优势

- 高度定制化，满足需要做兼容的一切场景
- 独立的通信机制和沙箱环境，可解决应用之间相互影响的问题
- 支持不同技术栈子应用，可无缝实现页面无刷新渲染

2. 劣势

- 技术实现难度过高
- 需要设计一套定制的通信机制
- 首次加载会出现资源过大的 问题

3. 最终实现

- 路由分发式
- 主应用控制路由匹配和子应用加载，共享依赖加载
- 子应用做功能，并接入主应用实现主子控制和联动
